-- 21.12.14
-- VIEW : 가상(VIRTUAL) TABLE
-- VIEW TABLE을 생성한 후에는 TABLE에서 사용가능한 SELECT, INSERT, UPDATE, DESC 등 SQL 커맨드 사용 가능
CREATE TABLE DEPT_COPY
AS
SELECT * FROM DEPT;

SELECT * FROM DEPT_COPY;

CREATE TABLE EMP_COPY
AS 
SELECT * FROM EMP;

SELECT * FROM EMP_COPY;

--VIEW TABLE 생성
CREATE VIEW EMP_VIEW30
AS
SELECT EMPNO, ENAME, DEPTNO
FROM EMP_COPY
WHERE DEPTNO=30;

SELECT * FROM EMP_VIEW30;
DESC EMP_VIEW30;

CREATE VIEW EMP_VIEW20
AS
SELECT EMPNO, ENAME, DEPTNO
FROM EMP_COPY
WHERE DEPTNO=20;

SELECT * FROM EMP_VIEW20;
DESC EMP_VIEW20;

-- 21.12.15
-- 사원테이블
-- - 이름, 주민등록번호, 집주소, 개인전화번호, 가족정보 (인사팀)
-- - 급여, 개인 인사평가결과 (인사팀)
-- - 영업실적 등급, 커미션 금액 (영업팀)
-- - 은행명 및 계좌번호 (경리팀)
-- => 인사팀용 사원 VIEW 테이블 생성, 경리팀용 사원 VIEW 테이블 생성
-- => 인사팀용 종합 VIEW 테이블을 만들 수도 있음(여러개의 테이블들을 JOIN하여 만들 수도 있음)
-- VIEW TABLE 은 APPLICATION이 오픈되고 난 후에 해당 회사의 각 부서들의 사용자들이 요구사항을 취합하여 통상 만듬
-- => APPLICATION(시스템) 이 오픈전에도 기본적인 VIEW TABLE은 만듬
-- ==> VIEW TABLE은 시스템이 오픈되고 난 후에라도 마음대로 CREATE VIEW TABLE하거나 DROP VIEW TABLE을 삭제할 수 있음

-- VIEW TABLE의 주요 용도는 회사의 각 부서에 속한 사람들이 원하는 정보를 조회하는 용도 위주로 사용함
-- => 즉, VIEW TABLE을 통해 원본 TABLE에 데이터를 생성, 수정, 삭제하는 것은 원칙적으로 불필요하고, 허용해서도 안됨

-- 웹사이트 게시글 등록 구현 : => 게시글 테이블에 게시글 ID (PRIMARY KEY)


-- VIEW TABLE의 내부 구조 살펴보기
DESC USER_VIEWS;

-- VIEW_NAME : CREATE VIEW로 생성한 VIEW NAME의미
-- TEXT : CREATE VIEW에서 AS 다음에 나오는 SUBQUERY 의미
SELECT VIEW_NAME, TEXT FROM USER_VIEWS;

-- VIEW TABLE인 EMP_VIEW30에 대해서 SELECT를 실행하면, 
-- ORACLE 내부적으로 TEXT에 있는 SUB QUERY를 실행함
-- 즉, 실제적으로는 VIEW TABLE의 원본 TABLE인 EMP_COPY의 SELECT 명령어를 ORACLE이 실행함
SELECT * FROM EMP_VIEW30;

-- VIEW TABLE에 INSERT 명령어 실행
-- VIEW TABLE에서 INSERT 명령어 실행하면, 실제 데이터는 VIEW TABLE의 원본 TABLE인 EMP_COPY에 저장됨
INSERT INTO EMP_VIEW30
VALUES (1111, 'AAAA', 30);

SELECT * FROM EMP_VIEW30;

SELECT * FROM EMP_COPY;

-- 단순 VIEW의 컬럼에 ALIAS(별칭) 부여하기
-- CREATE OR REPLACE : VIEW TABLE이 없으면 CREATE하고, VIEW TABLE이 기존에 있으면 REPLACE
-- CREATE VIEW로 생성된 VIEW를 삭제한 후 다시 생성할 경우에는 DROP VIEW, CREATE VIEW 명령어를 사용해야 함
-- CREATE OR REPLACE VIEW로 생성된 VIEW를 다시 생성할 경우에는 
--    CREATE OR REPLACE VIEW 명령어 한번만 사용하면 됨

--CREATE OR REPLACE VIEW EMP_VIEW (사원번호, 사원명, 급여, 부서번호)
CREATE VIEW EMP_VIEW (사원번호, 사원명, 급여, 부서번호)
AS
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP_COPY;

SELECT * FROM EMP_VIEW WHERE 부서번호=20;

-- 복합 VIEW 만들기
CREATE OR REPLACE VIEW EMP_VIEW_DEPT
AS
SELECT E.EMPNO, E.ENAME, E.SAL, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY EMPNO DESC;

SELECT * FROM EMP_VIEW_DEPT;

-- VIEW 삭제
DROP VIEW EMP_VIEW;

-- 조건 컬럼값을 변경하지 못하게 막는 WITH CHECK OPTION 사용하기
SELECT * FROM EMP_VIEW30;

UPDATE EMP_VIEW30
SET DEPTNO=20
WHERE EMPNO=1111;

INSERT INTO EMP_VIEW30
VALUES (2222, 'BBBB', 20);
SELECT * FROM EMP_COPY;

CREATE OR REPLACE VIEW VIEW_CHK30
AS
SELECT EMPNO, ENAME, SAL, COMM, DEPTNO
FROM EMP_COPY
WHERE DEPTNO=30 WITH CHECK OPTION;

SELECT * FROM VIEW_CHK30;

UPDATE VIEW_CHK30
SET DEPTNO = 20
WHERE EMPNO=7900;

UPDATE VIEW_CHK30
SET ENAME = 'JAMESJR'
WHERE EMPNO=7900;

-- VIEW를 통해 기본 테이블 변경을 막는 WITH READ ONLY (많이 사용됨, 가장 기본)
CREATE OR REPLACE VIEW VIEW_READ30
AS
SELECT EMPNO, ENAME, SAL, COMM, DEPTNO
FROM EMP_COPY
WHERE DEPTNO=30 WITH READ ONLY;

SELECT * FROM VIEW_READ30;
-- SQL 오류: ORA-42399: cannot perform a DML operation on a read-only view
UPDATE VIEW_READ30
SET COMM = 5000;

-- ROWNUM ; INLINE VIEW
SELECT * FROM EMP;

SELECT ROWNUM, EMP.* FROM EMP;

SELECT * 
FROM (SELECT * FROM EMP ORDER BY SAL DESC);

-- SAL이 상위 3명을 가져와라
-- (SELECT * FROM EMP ORDER BY SAL DESC) => INLINE VIEW
SELECT *
FROM (SELECT * FROM EMP ORDER BY SAL DESC)
WHERE ROWNUM <=3;

CREATE OR REPLACE VIEW VIEW_HIRE
AS
SELECT EMPNO, ENAME, HIREDATE
FROM EMP
ORDER BY HIREDATE;

-- VIEW TABLE을 새로 만들면, SUB QUERY 결과에 따라 ROWNUM이 새로 생성됨
SELECT ROWNUM, EMPNO, ENAME, HIREDATE
FROM VIEW_HIRE;

-- 입사일자가 가장 빠른 3명은?
SELECT * FROM VIEW_HIRE WHERE ROWNUM <=3;